<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dino Runner</title>
    <style>
        * { margin: 0; padding: 0; }
        body { 
            overflow: hidden;
            background: #f7f7f7;
            touch-action: manipulation;
        }
        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: #87CEEB;
        }
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.7);
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
            z-index: 10;
        }
        #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.7);
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
            z-index: 10;
        }
        button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 15px 30px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 18px;
            margin: 10px;
            cursor: pointer;
            border-radius: 5px;
        }
        .score-display {
            position: absolute;
            top: 10px;
            right: 10px;
            color: black;
            font-size: 16px; /* Fixed font size */
            font-family: 'Courier New', monospace;
            z-index: 5;
            background: rgba(255, 255, 255, 0.7); /* Light background to make black text visible */
            padding: 10px;
            border-radius: 5px;
            white-space: pre-line; /* Allow line breaks */
            text-align: right; /* Right-align the text */
            display: inline-block; /* Make box fit content */
            min-width: 100px; /* Smaller minimum width */
        }
        
        .mute-button {
            position: absolute;
            top: 10px;  /* Move back to top-left corner */
            left: 10px;
            background: none;
            border: none;
            cursor: pointer;
            z-index: 6;
            width: 40px;
            height: 40px;
            padding: 0;
        }
        
        .mute-button img {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="startScreen">
        <h1>ðŸ¦– DINO ADVENTURE</h1>
        <p>Press SPACE or TAP to jump over obstacles!</p>
        <p>Collect coins for extra lives!</p>
        <p>Your goal: Beat your high score!</p>
        <button id="startButton">ðŸŽ® START GAME</button>
    </div>
    <div id="gameOverScreen">
        <h1>ðŸ’¥ GAME OVER ðŸ’¥</h1>
        <p id="finalScore">Score: 0</p>
        <p>Don't give up! Try again to beat your record!</p>
        <button id="restartButton">ðŸ”„ PLAY AGAIN</button>
    </div>
    <div class="score-display" id="scoreDisplay">High: 0
Score: 0
Lives: 3</div>
    <button id="muteButton" class="mute-button" style="display: none;">
        <img id="muteIcon" src="assets/mute.png" alt="Mute" width="30" height="30">
    </button>

    <script src="config.js"></script>
    <script>
        // Game configuration
        const CONFIG = {
            GROUND_HEIGHT: 100,
            GRAVITY: 0.8,
            JUMP_FORCE: -18,  // Slightly higher jump (less negative value)
            BIRD_MIN_HEIGHT: 350,  // Increased minimum height for birds (accounting for taller player)
            BIRD_MAX_HEIGHT: 400, // Increased maximum height for birds (accounting for taller player)
            INITIAL_SPEED: 4,
            SPEED_INCREMENT: 0.01,
            OBSTACLE_MIN_GAP: 250,  // Increased minimum gap to make obstacles less frequent
            OBSTACLE_MAX_GAP: 500,  // Increased maximum gap to make obstacles less frequent
            OBSTACLE_MIN_HEIGHT: 40,
            OBSTACLE_MAX_HEIGHT: 80,
            ASSETS: {
                SKY: 'assets/sky.png',
                GROUND: 'assets/ground.png',
                PLAYER: 'assets/player.png',
                OBSTACLES_FOLDER: 'obstacles/'
            }
        };

        // Game state
        let gameState = {
            canvas: null,
            ctx: null,
            player: {
                x: 50,  // Moved further to the left for more reaction time
                y: 0,
                width: 120,  // Doubled width
                height: 240,  // Doubled height (previously was 120)
                velocityY: 0,
                isJumping: false
            },
            ground: {
                x1: 0,
                x2: 0,
                width: 0,
                height: CONFIG.GROUND_HEIGHT
            },
            obstacles: [],
            powerUps: [], // Array to hold power-up coins
            score: 0,
            highScore: 0,
            gameSpeed: CONFIG.INITIAL_SPEED,
            gameOver: false,
            lastObstacleTime: 0,  // Time when last obstacle was created
            nextObstacleInterval: 0,  // Time interval before next obstacle (in ms)
            lastPowerUpTime: 0,  // Time when last power-up was created
            nextPowerUpInterval: 0,  // Time interval before next power-up (in ms)
            assets: {
                sky: null,
                ground: null,
                player: null,
                obstacles: [],
                coin: null  // Coin asset for power-ups
            },
            imagesLoaded: 0,
            totalImages: 0,
            lives: 3,  // Number of lives for the player
            backgroundMusic: null,  // Audio element for background music
            hurtSound: null,  // Audio element for hurt sound
            jumpSound: null,  // Audio element for jump sound
            musicMuted: false  // Whether music is muted
        };

        // Load high score from localStorage
        function loadHighScore() {
            const savedHighScore = localStorage.getItem('dinoHighScore');
            gameState.highScore = savedHighScore ? parseInt(savedHighScore) : 0;
        }

        // Save high score to localStorage
        function saveHighScore() {
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
                localStorage.setItem('dinoHighScore', gameState.highScore.toString());
            }
        }

        // Update score display consistently
        function updateScoreDisplay() {
            const scoreElement = document.getElementById('scoreDisplay');
            // Display each element on a separate line
            scoreElement.textContent = `High: ${gameState.highScore}\nScore: ${gameState.score}\nLives: ${gameState.lives}`;
        }
        
        // Toggle music mute
        function toggleMute() {
            gameState.musicMuted = !gameState.musicMuted;
            
            if (gameState.backgroundMusic) {
                gameState.backgroundMusic.muted = gameState.musicMuted;
            }
            
            // Update mute button icon if needed (we can change this later if we have different icons for mute/unmute)
            // For now, we'll just keep the same icon, but functionality works
        }
        
        // Start background music
        function startBackgroundMusic() {
            if (gameState.backgroundMusic && !gameState.musicMuted) {
                gameState.backgroundMusic.play().catch(e => {
                    console.log("Audio play failed:", e);
                });
            }
        }
        
        // Pause background music
        function pauseBackgroundMusic() {
            if (gameState.backgroundMusic) {
                gameState.backgroundMusic.pause();
            }
        }

        // Preload assets
        function preloadAssets() {
            const imagePaths = [
                CONFIG.ASSETS.SKY,
                CONFIG.ASSETS.GROUND,
                CONFIG.ASSETS.PLAYER
            ];
            
            // Get obstacle files from server (simplified for Telegram)
            // In production, you'd have a predefined list or API endpoint
            const obstacleFiles = [
                'cactus2.png',
                'cactus2.png',
                'bird.png',
                'rock.png'
            ];
            
            obstacleFiles.forEach(file => {
                imagePaths.push(CONFIG.ASSETS.OBSTACLES_FOLDER + file);
            });
            
            // Add coin asset (assuming we have a coin.png in assets)
            imagePaths.push('assets/coin.png');
            
            gameState.totalImages = imagePaths.length + 1; // +1 for all audio files (they're handled together)
            
            imagePaths.forEach((path, index) => {
                const img = new Image();
                img.onload = () => {
                    gameState.imagesLoaded++;
                    if (index === 0) gameState.assets.sky = img;
                    else if (index === 1) gameState.assets.ground = img;
                    else if (index === 2) gameState.assets.player = img;
                    else if (index === imagePaths.length - 1) { // Last item is coin
                        gameState.assets.coin = img;
                    } else {
                        // Scale obstacle while maintaining aspect ratio
                        const scale = Math.random() * 
                            (CONFIG.OBSTACLE_MAX_HEIGHT - CONFIG.OBSTACLE_MIN_HEIGHT) / img.height 
                            + (CONFIG.OBSTACLE_MIN_HEIGHT / img.height);
                        const scaledWidth = img.width * scale;
                        const scaledHeight = img.height * scale;
                        
                        const canvas = document.createElement('canvas');
                        canvas.width = scaledWidth;
                        canvas.height = scaledHeight;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, scaledWidth, scaledHeight);
                        
                        gameState.assets.obstacles.push(canvas);
                    }
                };
                img.onerror = () => {
                    console.error(`Failed to load asset: ${path}`);
                    // If coin asset fails to load, we can create a simple circle instead
                    if (index === imagePaths.length - 1) { // Last item is coin
                        const canvas = document.createElement('canvas');
                        canvas.width = 30;
                        canvas.height = 30;
                        const ctx = canvas.getContext('2d');
                        ctx.fillStyle = '#FFD700';
                        ctx.beginPath();
                        ctx.arc(15, 15, 12, 0, Math.PI * 2); // Gold-colored coin
                        ctx.fill();
                        ctx.strokeStyle = '#DAA520';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        gameState.assets.coin = canvas;
                    }
                    gameState.imagesLoaded++;
                };
                img.src = path;
            });
            
            // Create audio element for background music
            gameState.backgroundMusic = new Audio('assets/back.mp3');
            gameState.backgroundMusic.loop = true; // Loop the music
            gameState.backgroundMusic.volume = 0.5; // Set initial volume
            
            // Create audio element for hurt sound
            gameState.hurtSound = new Audio('assets/hurt.mp3');
            gameState.hurtSound.volume = 0.7; // Set volume for hurt sound
            
            // Create audio element for jump sound
            gameState.jumpSound = new Audio('assets/jump.mp3');
            gameState.jumpSound.volume = 0.6; // Set volume for jump sound
            
            // Load audio and then continue with game initialization
            let audioLoadedCount = 0;
            const handleAudioLoad = () => {
                audioLoadedCount++;
                if (audioLoadedCount === 3) { // All three audio files loaded or failed
                    gameState.imagesLoaded++; // Increment to account for audio loading
                }
            };
            
            gameState.backgroundMusic.addEventListener('canplaythrough', handleAudioLoad);
            gameState.hurtSound.addEventListener('canplaythrough', handleAudioLoad);
            gameState.jumpSound.addEventListener('canplaythrough', handleAudioLoad);
            
            gameState.backgroundMusic.addEventListener('error', () => {
                console.error('Failed to load background music');
                handleAudioLoad(); // Still count as loaded to not hang the game
            });
            
            gameState.hurtSound.addEventListener('error', () => {
                console.error('Failed to load hurt sound');
                handleAudioLoad(); // Still count as loaded to not hang the game
            });
            
            gameState.jumpSound.addEventListener('error', () => {
                console.error('Failed to load jump sound');
                handleAudioLoad(); // Still count as loaded to not hang the game
            });
            
            // Start loading all audio files
            gameState.backgroundMusic.load();
            gameState.hurtSound.load();
            gameState.jumpSound.load();
        }

        // Initialize game
        function initGame() {
            gameState.canvas = document.getElementById('gameCanvas');
            gameState.ctx = gameState.canvas.getContext('2d');
            
            // Set canvas size to fill screen
            gameState.canvas.width = window.innerWidth;
            gameState.canvas.height = window.innerHeight;
            
            // Adjust ground position
            gameState.ground.width = gameState.canvas.width;
            gameState.ground.x1 = 0;
            gameState.ground.x2 = gameState.canvas.width;
            gameState.player.y = gameState.canvas.height - CONFIG.GROUND_HEIGHT - gameState.player.height;
            
            // Reset game state
            gameState.obstacles = [];
            gameState.powerUps = []; // Reset power-ups
            gameState.score = 0;
            gameState.gameSpeed = CONFIG.INITIAL_SPEED;
            gameState.gameOver = false;
            gameState.lives = 3; // Reset lives to 3 on new game
            gameState.lastObstacleTime = Date.now();
            gameState.lastPowerUpTime = Date.now(); // Reset power-up timer
            // Set time interval for obstacle spawning using external configuration
            gameState.nextObstacleInterval = Math.random() * 
                (OBSTACLE_CONFIG.MAX_OBSTACLE_INTERVAL - OBSTACLE_CONFIG.MIN_OBSTACLE_INTERVAL) + 
                OBSTACLE_CONFIG.MIN_OBSTACLE_INTERVAL;
            
            // Hide UI screens
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameOverScreen').style.display = 'none';
            
            // Show mute button
            document.getElementById('muteButton').style.display = 'block';
            
            // Update score display
            updateScoreDisplay();
            
            // Start background music
            startBackgroundMusic();
            
            // Start game loop
            requestAnimationFrame(gameLoop);
        }

        // Create new obstacle
        function createObstacle() {
            const obstacleIndex = Math.floor(Math.random() * gameState.assets.obstacles.length);
            const obstacleImg = gameState.assets.obstacles[obstacleIndex];
            
            // Check if this obstacle is a bird by looking for "bird" in its filename/index
            // We'll determine this by checking if it's likely a bird image based on the index
            // Assuming the bird.png is loaded as one of the obstacles (index 2 in the original list)
            // But to be more robust, let's create the obstacle first and then determine if it's a bird
            const obstacle = {
                x: gameState.canvas.width,
                y: gameState.canvas.height - CONFIG.GROUND_HEIGHT - obstacleImg.height,
                width: obstacleImg.width,
                height: obstacleImg.height,
                img: obstacleImg,
                passed: false,
                isBird: false  // Add a property to identify if this is a bird
            };
            
            // Determine if this is a bird (for now, we'll use the index - in original setup bird.png was 3rd entry)
            // Better approach: Check based on the type of obstacle - birds should be placed higher
            // We'll implement a more robust check later
            
            // For now, we'll identify birds by checking if we're using the bird.png asset
            // Since we can't directly check the source, let's make all birds positioned at proper height
            // by creating them at the appropriate y position
            if (Math.random() > 0.7) { // Still using random chance to make some birds
                // Position birds at appropriate height - higher than player can jump
                // With taller character and higher jump force, we need to adjust bird positioning
                const birdHeight = Math.random() * 
                    (CONFIG.BIRD_MAX_HEIGHT - CONFIG.BIRD_MIN_HEIGHT) + 
                    CONFIG.BIRD_MIN_HEIGHT; // Use updated config values
                obstacle.y = gameState.canvas.height - CONFIG.GROUND_HEIGHT - birdHeight - obstacleImg.height;
                obstacle.isBird = true;
            }
            
            gameState.obstacles.push(obstacle);
            gameState.lastObstacleTime = Date.now();
            // Set time for next obstacle based on external config
            gameState.nextObstacleInterval = Math.random() * 
                (OBSTACLE_CONFIG.MAX_OBSTACLE_INTERVAL - OBSTACLE_CONFIG.MIN_OBSTACLE_INTERVAL) + 
                OBSTACLE_CONFIG.MIN_OBSTACLE_INTERVAL;
        }

        // Create new power-up (coin)
        function createPowerUp() {
            // Limit coin Y position to a reasonable range where player can reach it
            // Account for player's jump height and size to ensure coins are always reachable
            const maxCoinY = gameState.canvas.height - CONFIG.GROUND_HEIGHT - 80; // Higher up from ground (closer to player jump range)
            const minCoinY = 100; // Lower maximum height to ensure reachability
            const coinYRange = Math.max(0, maxCoinY - minCoinY);
            
            const powerUp = {
                x: gameState.canvas.width,
                y: Math.random() * coinYRange + minCoinY, // Constrained Y position
                width: 40,  // Increased size to match larger game elements
                height: 40, // Increased size to match larger game elements
                collected: false
            };
            
            gameState.powerUps.push(powerUp);
            gameState.lastPowerUpTime = Date.now();
            // Set time for next power-up (random interval between 5-15 seconds)
            gameState.nextPowerUpInterval = Math.random() * 10000 + 5000; // 5-15 seconds
        }

        // Check collision between two rectangles
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        // Update game state
        function update() {
            if (gameState.gameOver) return;
            
            // Update player
            gameState.player.velocityY += CONFIG.GRAVITY;
            gameState.player.y += gameState.player.velocityY;
            
            // Ground collision
            const groundLevel = gameState.canvas.height - CONFIG.GROUND_HEIGHT - gameState.player.height;
            if (gameState.player.y > groundLevel) {
                gameState.player.y = groundLevel;
                gameState.player.velocityY = 0;
                gameState.player.isJumping = false;
            }
            
            // Update ground
            gameState.ground.x1 -= gameState.gameSpeed;
            gameState.ground.x2 -= gameState.gameSpeed;
            
            if (gameState.ground.x1 + gameState.ground.width <= 0) {
                gameState.ground.x1 = gameState.ground.x2 + gameState.ground.width;
            }
            
            if (gameState.ground.x2 + gameState.ground.width <= 0) {
                gameState.ground.x2 = gameState.ground.x1 + gameState.ground.width;
            }
            
            // Update obstacles
            for (let i = gameState.obstacles.length - 1; i >= 0; i--) {
                const obstacle = gameState.obstacles[i];
                obstacle.x -= gameState.gameSpeed;
                
                // Check collision with reduced hitbox for obstacles (10% smaller on each side for easier gameplay)
                // But ensure minimum hitbox size for very small obstacles
                const minObstacleHitboxWidth = 15;  // Minimum width for obstacle hitbox
                const minObstacleHitboxHeight = 15; // Minimum height for obstacle hitbox
                
                const reducedObstacleWidth = Math.max(obstacle.width * 0.7, minObstacleHitboxWidth);
                const reducedObstacleHeight = Math.max(obstacle.height * 0.7, minObstacleHitboxHeight);
                
                const reducedObstacle = {
                    x: obstacle.x + ((obstacle.width - reducedObstacleWidth) / 2), // Center the hitbox horizontally
                    y: obstacle.y + ((obstacle.height - reducedObstacleHeight) / 2), // Center the hitbox vertically
                    width: reducedObstacleWidth,
                    height: reducedObstacleHeight
                };
                
                // Also reduce player hitbox by 10% on each side with minimum size
                const minPlayerHitboxWidth = 30;  // Minimum width for player hitbox
                const minPlayerHitboxHeight = 60; // Minimum height for player hitbox
                
                const reducedPlayerWidth = Math.max(gameState.player.width * 0.7, minPlayerHitboxWidth);
                const reducedPlayerHeight = Math.max(gameState.player.height * 0.7, minPlayerHitboxHeight);
                
                const reducedPlayer = {
                    x: gameState.player.x + ((gameState.player.width - reducedPlayerWidth) / 2), // Center the hitbox horizontally
                    y: gameState.player.y + ((gameState.player.height - reducedPlayerHeight) / 2), // Center the hitbox vertically
                    width: reducedPlayerWidth,
                    height: reducedPlayerHeight
                };
                
                if (checkCollision(reducedPlayer, reducedObstacle)) {
                    gameState.lives--; // Lose a life on collision
                    updateScoreDisplay(); // Update display when life is lost
                    
                    // Play hurt sound when losing a life
                    if (gameState.hurtSound && !gameState.musicMuted) {
                        // Clone the audio to allow overlapping sounds
                        const hurtAudio = new Audio('assets/hurt.mp3');
                        hurtAudio.volume = 0.7;
                        hurtAudio.play().catch(e => console.log("Hurt sound play failed:", e));
                    }
                    
                    if (gameState.lives <= 0) {
                        gameState.gameOver = true;
                    } else {
                        // Remove the obstacle that caused the collision
                        gameState.obstacles.splice(i, 1);
                    }
                }
                
                // Score when passing obstacle
                if (!obstacle.passed && obstacle.x + obstacle.width < gameState.player.x) {
                    gameState.score++;
                    obstacle.passed = true;
                    updateScoreDisplay(); // Use the consistent function
                    
                    // Increase speed every 5 points instead of 10
                    if (gameState.score % 5 === 0) {
                        gameState.gameSpeed += CONFIG.SPEED_INCREMENT;
                    }
                }
                
                // Remove off-screen obstacles
                if (obstacle.x + obstacle.width < 0) {
                    gameState.obstacles.splice(i, 1);
                }
            }
            
            // Update power-ups
            for (let i = gameState.powerUps.length - 1; i >= 0; i--) {
                const powerUp = gameState.powerUps[i];
                if (!powerUp.collected) {
                    powerUp.x -= gameState.gameSpeed;
                    
                    // Check collision with player
                    if (checkCollision(
                        {
                            x: gameState.player.x,
                            y: gameState.player.y,
                            width: gameState.player.width,
                            height: gameState.player.height
                        },
                        powerUp
                    )) {
                        // Collect the power-up: add an extra life
                        gameState.lives++;
                        powerUp.collected = true;
                        
                        // Update score display to show the extra life
                        updateScoreDisplay(); // Use the consistent function
                    }
                    
                    // Remove off-screen power-ups
                    if (powerUp.x + powerUp.width < 0) {
                        gameState.powerUps.splice(i, 1);
                    }
                }
            }
            
            // Create new obstacles based on time interval to make them less frequent
            if (Date.now() - gameState.lastObstacleTime > gameState.nextObstacleInterval) {
                createObstacle();
            }
            
            // Create new power-ups based on time interval
            if (Date.now() - gameState.lastPowerUpTime > gameState.nextPowerUpInterval) {
                createPowerUp();
            }
        }

        // Draw game elements
        function draw() {
            const ctx = gameState.ctx;
            
            // Clear canvas
            ctx.clearRect(0, 0, gameState.canvas.width, gameState.canvas.height);
            
            // Draw sky background
            if (gameState.assets.sky) {
                ctx.drawImage(
                    gameState.assets.sky, 
                    0, 0, 
                    gameState.canvas.width, 
                    gameState.canvas.height
                );
            } else {
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, gameState.canvas.width, gameState.canvas.height - CONFIG.GROUND_HEIGHT);
            }
            
            // Draw ground
            // if (gameState.assets.ground) {
            //     // Draw first ground segment
            //     ctx.drawImage(
            //         gameState.assets.ground,
            //         gameState.ground.x1, 
            //         gameState.canvas.height - CONFIG.GROUND_HEIGHT,
            //         gameState.ground.width,
            //         CONFIG.GROUND_HEIGHT
            //     );
            //
            //     // Draw second ground segment
            //     ctx.drawImage(
            //         gameState.assets.ground,
            //         gameState.ground.x2, 
            //         gameState.canvas.height - CONFIG.GROUND_HEIGHT,
            //         gameState.ground.width,
            //         CONFIG.GROUND_HEIGHT
            //     );
            // } else {
            //     ctx.fillStyle = '#8B4513';
            //     ctx.fillRect(0, gameState.canvas.height - CONFIG.GROUND_HEIGHT, gameState.canvas.width, CONFIG.GROUND_HEIGHT);
            // }
            //
            // Draw power-ups (coins)
            gameState.powerUps.forEach(powerUp => {
                if (!powerUp.collected && gameState.assets.coin) {
                    ctx.drawImage(
                        gameState.assets.coin,
                        powerUp.x,
                        powerUp.y,
                        powerUp.width,
                        powerUp.height
                    );
                } else if (!powerUp.collected) {
                    // Draw a simple circle if coin asset failed to load
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(
                        powerUp.x + powerUp.width/2, 
                        powerUp.y + powerUp.height/2, 
                        powerUp.width/2, 
                        0, 
                        Math.PI * 2
                    );
                    ctx.fill();
                    ctx.strokeStyle = '#DAA520';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });
            
            // Draw obstacles
            gameState.obstacles.forEach(obstacle => {
                ctx.drawImage(
                    obstacle.img,
                    obstacle.x,
                    obstacle.y,
                    obstacle.width,
                    obstacle.height
                );
            });
            
            // Draw player
            if (gameState.assets.player) {
                ctx.drawImage(
                    gameState.assets.player,
                    gameState.player.x,
                    gameState.player.y,
                    gameState.player.width,
                    gameState.player.height
                );
            } else {
                ctx.fillStyle = '#333';
                ctx.fillRect(
                    gameState.player.x,
                    gameState.player.y,
                    gameState.player.width,
                    gameState.player.height
                );
            }
        }

        // Main game loop
        function gameLoop() {
            if (gameState.imagesLoaded < gameState.totalImages) {
                requestAnimationFrame(gameLoop);
                return;
            }
            
            update();
            draw();
            
            if (gameState.gameOver) {
                saveHighScore(); // Save high score when game ends
                pauseBackgroundMusic(); // Pause background music when game ends
                updateScoreDisplay(); // Make sure display is updated before game ends
                document.getElementById('finalScore').textContent = `Score: ${gameState.score} | Best: ${gameState.highScore}`;
                document.getElementById('gameOverScreen').style.display = 'flex';
                return;
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Handle jump
        function handleJump() {
            if (gameState.gameOver || gameState.player.isJumping) return;
            
            gameState.player.velocityY = CONFIG.JUMP_FORCE;
            gameState.player.isJumping = true;
            
            // Play jump sound when player actually jumps
            if (gameState.jumpSound && !gameState.musicMuted) {
                // Clone the audio to allow overlapping sounds
                const jumpAudio = new Audio('assets/jump.mp3');
                jumpAudio.volume = 0.6;
                jumpAudio.play().catch(e => console.log("Jump sound play failed:", e));
            }
        }

        // Event listeners
        document.getElementById('startButton').addEventListener('click', initGame);
        document.getElementById('restartButton').addEventListener('click', initGame);
        document.getElementById('muteButton').addEventListener('click', toggleMute);
        
        // Touch and click events for jumping
        document.addEventListener('click', handleJump);
        document.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleJump();
        });
        
        // Keyboard event for spacebar jump on desktop
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.key === ' ') {
                e.preventDefault(); // Prevent scrolling when spacebar is pressed
                handleJump();
            }
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            if (gameState.canvas) {
                gameState.canvas.width = window.innerWidth;
                gameState.canvas.height = window.innerHeight;
                gameState.ground.width = gameState.canvas.width;
                gameState.player.y = gameState.canvas.height - CONFIG.GROUND_HEIGHT - gameState.player.height;
            }
        });

        // Initialize
        loadHighScore(); // Load high score before starting the game
        preloadAssets();
    </script>
</body>
</html>
